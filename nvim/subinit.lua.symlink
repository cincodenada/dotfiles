-- Until they get their shit together into some sort of sensible policy, my god
vim.deprecate = function() end

require("config.lazy")
-- Custom keys
--vim.keymap.set('n', '<Leader>en', function() { require('trouble').next({skip_groups=true, jump=true}) })

--vim.keymap.set('n', '<Leader>ep', vim.diagnostic.goto_prev)

-- Come on, there's gotta be a better way to do this
vim.cmd"set t_Co=256"
vim.cmd"colorscheme desert-warm-256"

vim.keymap.set('n', '<Leader>es', vim.diagnostic.show)
vim.keymap.set('n', '<Leader>eh', vim.diagnostic.hide)
vim.keymap.set('n', '<Leader>en', function() vim.diagnostic.goto_next({severity=vim.diagnostic.severity.ERROR}) end )
vim.keymap.set('n', '<Leader>ep', function() vim.diagnostic.goto_prev({severity=vim.diagnostic.severity.ERROR}) end )
vim.keymap.set('n', '<Leader>ew', "<cmd>Trouble<cr>")
vim.keymap.set('n', '<Leader>ei', vim.diagnostic.open_float)
vim.keymap.set('n', '<Leader>i', vim.lsp.buf.hover)
vim.keymap.set('n', '<Leader>q', vim.lsp.buf.format)

-- Temp fix for javascript indenting
-- https://github.com/nvim-treesitter/nvim-treesitter/issues/1167
function _G.javascript_indent()
	local line = vim.fn.getline(vim.v.lnum)
	local prev_line = vim.fn.getline(vim.v.lnum - 1)
	if line:match('^%s*[%*/]%s*') then
		if prev_line:match('^%s*%*%s*') then
			return vim.fn.indent(vim.v.lnum - 1)
		end
		if prev_line:match('^%s*/%*%*%s*$') then
			return vim.fn.indent(vim.v.lnum - 1) + 1
		end
	end

	return vim.fn['GetJavascriptIndent']()
end

vim.cmd[[autocmd FileType javascript setlocal indentexpr=v:lua.javascript_indent()]]

--require('org-idle.org-idle').setup()
-- This shouldn't be necessary but it seems to get wonky sometimes
--vim.api.nvim_create_autocmd({"WinNew", "WinEnter"}, {
--	pattern={"orgagenda"},
--	callback=function(ev)
--		vim.cmd("resize 10")
--		vim.api.nvim_win_set_option(0, "winfixheight", true)
--		-- Reset cmdheight, since this can screw with that
--		vim.o.cmdheight = 1
--		vim.wo.conceallevel=2
--		vim.wo.concealcursor='nvc'
--	end
--})

--local fallback_jump = function()
--	local oldlevel = vim.lsp.log.get_level()
--	vim.lsp.log.set_level(10)
--	if not vim.lsp.buf.definition() then
--		vim.cmd("tag <cword>")
--	end
--end
--

local function filter_diagnostics(ctx)
	return function (diagnostic)
		local tsIgnoreCodes = {
			7044, -- Parameter type inference
			7047, -- Same?
			80001, -- CommonJS module
			6133, -- delared-not-used, duplicative of linting and incorrect for React
			2686, -- UMD global in module
			-- Not enough info:
			--2339, -- property does not exist
			--2349, -- expression is not callable
			--2306, -- not a module
			--2304, -- cannot find name
			--2552, -- cannot find name w/ suggestion?
		}

		-- TODO: Figure out how to get filetype of this diag
		--local filetype = vim.filetype.match({ buf = ctx.bufnr })

		if diagnostic.source == "typescript" then
			--if vim.startswith(filetype, "javascript") and vim.tbl_contains(tsIgnoreCodes, diagnostic.code) then
			if vim.tbl_contains(tsIgnoreCodes, diagnostic.code) then
				return false
			end
		end
		return true
	end
end

vim.lsp.handlers['textDocument/publishDiagnostics'] = vim.lsp.with(
	function(_, result, ctx, config)
		result.diagnostics = vim.tbl_filter(filter_diagnostics(ctx), result.diagnostics)
		vim.lsp.diagnostic.on_publish_diagnostics(_, result, ctx, config)
	end,
	{}
)


local source_abbrev = {
	typescript = "TS",
	eslint = "ESL",
	eslint_d = "ESL",
	stylelintplus = "STYL",
}

vim.diagnostic.config{
	virtual_text = {
		format = function(diagnostic)
			code = source_abbrev[diagnostic.source] or diagnostic.source
			if diagnostic.code then
				code = code.."."..diagnostic.code
			end
			return string.format(
				"%s: %s", code, diagnostic.message
			)
		end
	}
}

local runtime_path = vim.split(package.path, ';')
table.insert(runtime_path, "lua/?.lua")
table.insert(runtime_path, "lua/?/init.lua")

--require'lspconfig'.sumneko_lua.setup {
--	settings = {
--		Lua = {
--			runtime = {
--				-- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
--				version = 'LuaJIT',
--				-- Setup your lua path
--				path = runtime_path,
--			},
--			diagnostics = {
--				-- Get the language server to recognize the `vim` global
--				globals = {'vim'},
--			},
--			workspace = {
--				-- Make the server aware of Neovim runtime files
--				library = vim.api.nvim_get_runtime_file("", true),
--			},
--			-- Do not send telemetry data containing a randomized but unique identifier
--			telemetry = {
--				enable = false,
--			},
--		},
--	},
--}

package.path = package.path .. ";" .. vim.fn.stdpath("config") .. "/?.lua"
require('print_table')

function rerequire(path)
	package.loaded[path] = nil
	return require(path)
end
