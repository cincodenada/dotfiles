-- vim:noet:sw=2:ts=2
-- Custom keys
--vim.keymap.set('n', '<Leader>en', function() { require('trouble').next({skip_groups=true, jump=true}) })

--vim.keymap.set('n', '<Leader>ep', vim.diagnostic.goto_prev)

vim.keymap.set('n', '<Leader>es', vim.diagnostic.show)
vim.keymap.set('n', '<Leader>eh', vim.diagnostic.hide)
vim.keymap.set('n', '<Leader>en', function() vim.diagnostic.goto_next({severity=vim.diagnostic.severity.ERROR}) end )
vim.keymap.set('n', '<Leader>ep', function() vim.diagnostic.goto_prev({severity=vim.diagnostic.severity.ERROR}) end )
vim.keymap.set('n', '<Leader>ew', "<cmd>Trouble<cr>")
vim.keymap.set('n', '<Leader>ei', vim.diagnostic.open_float)
vim.keymap.set('n', '<Leader>i', vim.lsp.buf.hover)
vim.keymap.set('n', '<Leader>q', vim.lsp.buf.format)

-- Temp fix for javascript indenting
-- https://github.com/nvim-treesitter/nvim-treesitter/issues/1167
function _G.javascript_indent()
	local line = vim.fn.getline(vim.v.lnum)
	local prev_line = vim.fn.getline(vim.v.lnum - 1)
	if line:match('^%s*[%*/]%s*') then
		if prev_line:match('^%s*%*%s*') then
			return vim.fn.indent(vim.v.lnum - 1)
		end
		if prev_line:match('^%s*/%*%*%s*$') then
			return vim.fn.indent(vim.v.lnum - 1) + 1
		end
	end

	return vim.fn['GetJavascriptIndent']()
end

vim.cmd[[autocmd FileType javascript setlocal indentexpr=v:lua.javascript_indent()]]

-- Tree-sitter configuration
require'nvim-treesitter.configs'.setup {
	-- If TS highlights are not enabled at all, or disabled via `disable` prop, highlighting will fallback to default Vim syntax highlighting
	highlight = {
		enable = true,
		disable = {'org'}, -- Remove this to use TS highlighter for some of the highlights (Experimental)
		additional_vim_regex_highlighting = true, -- Required since TS highlighter doesn't support all syntax features (conceal)
	},
	--indent = {
	--	enable = true
	--},
	incremental_selection = {
		enable = true,
		keymaps = {
			-- init_selection = "<cr>",
			node_incremental = "gsn",
			node_decremental = "gsN",
			scope_incremental = "gsc",
			scope_decremental = "gsC",
		},
	},
	ensure_installed = {'org'}, -- Or run :TSUpdate org
}

local parser_config = require('nvim-treesitter.parsers').get_parser_configs()
parser_config.kdl = {
	install_info = {
		url = "https://github.com/spaarmann/tree-sitter-kdl",
		files = { "src/parser.c", "src/scanner.c" },
		branch = "main",
	},
}
vim.treesitter.language.register("kdl", "kdl")

require('orgmode').setup({
	org_agenda_files = { '~/Sync/org/**/*' },
	org_default_notes_file = '~/Sync/org/tailormed/tofile.org',
	mappings = {
		org = {
			org_toggle_checkbox = '<Leader>cc',
			org_meta_return = '<cr>',
			org_open_at_point = 'gx',
		}
	},
	win_split_mode = "topleft 10new",
	org_todo_keywords = { 'TODO', 'DOING', '|', 'DONE' },
	org_capture_templates = {
		t = { description = 'Task', template = "* TODO %?\n  %u" },
		f = { description = 'File Task', template = "* TODO %?\n	%u\n	%a" },
	},
	org_blank_before_new_entry = { heading = false },
	--org_agenda_skip_scheduled_if_done = true,
	--org_agenda_skip_deadline_if_done = true,
})
-- Load custom tree-sitter grammar for org filetype
require('orgmode').setup_ts_grammar()
require('org-idle.org-idle').setup()
-- This shouldn't be necessary but it seems to get wonky sometimes
--vim.api.nvim_create_autocmd({"WinNew", "WinEnter"}, {
--	pattern={"orgagenda"},
--	callback=function(ev)
--		vim.cmd("resize 10")
--		vim.api.nvim_win_set_option(0, "winfixheight", true)
--		-- Reset cmdheight, since this can screw with that
--		vim.o.cmdheight = 1
--		vim.wo.conceallevel=2
--		vim.wo.concealcursor='nvc'
--	end
--})

local util = require 'lspconfig.util'
local configs = require 'lspconfig.configs'

configs.ast_grep = {
	default_config = {
		cmd = {'sg', 'lsp'};
		filetypes = {'typescript', 'javascript'};
		single_file_support = true;
		root_dir = util.root_pattern('.git', 'sgconfig.yml');
	};
}

--local fallback_jump = function()
--	local oldlevel = vim.lsp.log.get_level()
--	vim.lsp.log.set_level(10)
--	if not vim.lsp.buf.definition() then
--		vim.cmd("tag <cword>")
--	end
--end

local setup_lsp = function(client, bufnr, use_formatter)
	-- We want to prefer Prettier over type-specific formatters
	if client.name == "tsserver" then
		client.server_capabilities.documentFormattingProvider = false
		client.server_capabilities.documentRangeFormattingProvider = false

		local filetype = vim.filetype.match({ buf = bufnr })
		local ignoredCodes = (filetype and vim.startswith(filetype, "javascript")) and {
			7044, -- Parameter type inference
			7047, -- Same?
			80001, -- CommonJS module
			6133, -- delared-not-used, duplicative of linting and incorrect for React
			-- Not enough info:
			2339, -- property does not exist
			2349, -- expression is not callable
			2306, -- not a module
			2304, -- cannot find name
			2552, -- cannot find name w/ suggestion?
		} or {}

		client.notify('workspace/didChangeConfiguration', {
			diagnostics = {
				ignoredCodes = ignoredCodes
			}
		})
	else
		print(vim.inspect(client))
	end

	-- See `:help nvim_buf_set_keymap()` for more information
	vim.api.nvim_buf_set_keymap(bufnr, 'n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', {noremap = true})
	vim.api.nvim_buf_set_keymap(bufnr, 'n', '<c-]>', '<cmd>lua vim.lsp.buf.definition()<CR>', {noremap = true})
	-- ... and other keymappings for LSP

	-- Use LSP as the handler for omnifunc.
	--		See `:help omnifunc` and `:help ins-completion` for more information.
	vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

	-- Use LSP as the handler for formatexpr.
	--		See `:help formatexpr` for more information.
	vim.api.nvim_buf_set_option(bufnr, 'formatexpr', 'v:lua.vim.lsp.formatexpr')

	--vim.lsp.buf.inlay_hint(bufnr, true)

	-- For plugins with an `on_attach` callback, call them here. For example:
	-- require('completion').on_attach()
end

require('typescript').setup({
	server = {
		on_attach = setup_lsp,
	}
})

local source_abbrev = {
	typescript = "TS",
	eslint = "ESL",
	eslint_d = "ESL",
	stylelintplus = "STYL",
}

vim.diagnostic.config{
	virtual_text = {
		format = function(diagnostic)
			code = source_abbrev[diagnostic.source] or diagnostic.source
			if diagnostic.code then
				code = code.."."..diagnostic.code
			end
			return string.format(
				"%s: %s", code, diagnostic.message
			)
		end
	}
}

local runtime_path = vim.split(package.path, ';')
table.insert(runtime_path, "lua/?.lua")
table.insert(runtime_path, "lua/?/init.lua")

--require'lspconfig'.sumneko_lua.setup {
--	settings = {
--		Lua = {
--			runtime = {
--				-- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
--				version = 'LuaJIT',
--				-- Setup your lua path
--				path = runtime_path,
--			},
--			diagnostics = {
--				-- Get the language server to recognize the `vim` global
--				globals = {'vim'},
--			},
--			workspace = {
--				-- Make the server aware of Neovim runtime files
--				library = vim.api.nvim_get_runtime_file("", true),
--			},
--			-- Do not send telemetry data containing a randomized but unique identifier
--			telemetry = {
--				enable = false,
--			},
--		},
--	},
--}

require('trouble').setup{
	icons = false,
	fold_open = "‚ñº",
	fold_closed = "‚ñ∂",
	indent_lines = false,
	signs = {
		error = "‚õîÔ∏è",
		warning = "‚ö†Ô∏è",
		hint = "ü§ñ",
		information = "üíÅ",
	},
}

require("null-ls").setup({
	on_attach = setup_lsp,
	sources = {
		--require("null-ls").builtins.diagnostics.eslint,
		--require("null-ls").builtins.code_actions.eslint_d,
		require("null-ls").builtins.diagnostics.eslint_d,
		require("null-ls").builtins.formatting.eslint_d,
		require("null-ls").builtins.completion.spell,
		require("null-ls").builtins.formatting.prettier,
	},
	root_dir = util.root_pattern("package.json", ".git")
})

require'lspconfig'.stylelint_lsp.setup{
	cmd = { "/Users/joel/.nvm/versions/node/v16.17.1/bin/stylelint-lsp", "--stdio" },
	settings = {
		stylelintplus = {}
	}
}

require('eslint').setup({
	bin = 'eslint_d',
	code_actions = {
		enable = true,
	}
})

require('prettier').setup({
	bin = 'prettierd',
	filetypes = {
		"css",
		"graphql",
		"html",
		"javascript",
		"javascriptreact",
		"json",
		"less",
		"markdown",
		"scss",
		"typescript",
		"typescriptreact",
		"yaml",
	},
	root_dir = util.root_pattern("package.json", ".git")
})

require'telescope'.setup{
	defaults = {
		path_display={"smart"}
	},
	extensions = {
		ast_grep = {
			command = {
				"sg",
				"--json=stream",
			},
			grep_open_files = false,
			lang = nil,
		}
	},
}
require'telescope'.load_extension'fzf'
require'telescope'.load_extension'repo'
require'telescope'.load_extension'ast_grep'

--require('nvim-test').setup({
--	runners = {
--		javascript = "nvim-test.runners.mocha",
--	}
--})

--require('nvim-test.runners.mocha'):setup({
--	command = "npm test",
--	args = {},
--	env = {},
--	find_files = {"test/{name}.{ext}"},
--})

require('coverage').setup()

package.path = package.path .. ";" .. vim.fn.stdpath("config") .. "/?.lua"
require('print_table')

function rerequire(path)
	package.loaded[path] = nil
	return require(path)
end
